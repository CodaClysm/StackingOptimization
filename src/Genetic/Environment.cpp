#include <iostream>
#include "Environment.h"
#include "ControllerSettings.h"
#include "../Utils/DebugLogger.h"

/*
* Function: Environment ctor
* Parameters: 
* Description: Creates a new environment to use with dimsensions from settings
*/
Environment::Environment()
{
    currentState = State();
}

/*
* Function: getPossibleStates
* Parameters: 
*   Shape shape: the new shape to be placed inside of the environment
* Description: Checks all positions where the new shape can be placed
    returns a list of all possible States that the new shape can create
*/
vector<State> Environment::getPossibleStates(Shape shapeToPlace)
{
    vector<State> returnVector;

    // Create local variables to make code more readable
    int envX = ControllerSettings::envShape.getX();
    int envY = ControllerSettings::envShape.getY();
    int envZ = ControllerSettings::envShape.getZ();

    //make sure the shape is able to fit in the environment
    for(Shape shape : shapeToPlace.getUniqueOrientations())
    {
        if(shape.getX() <= envX
           && shape.getY() <= envY
           && shape.getZ() <= envZ)
        {
            //iterate through all locations that the shape can fit at the top of the container
            for(int x = 0; x < envX - shape.getX() + 1; x++)
            {
                for(int z = 0; z < envZ - shape.getZ() + 1; z++)
                {
                    State previous;
                    //drop the shape for every x-z location until it collides in Y direction
                    for(int y = envY-1; y >= shape.getY()-1 ; y--)
                    {
                        State shapeState = testShape(x, z, y, shape);
                        if(isCollision(shapeState))
                        {
                            if(y == envY -1)
                            {
                                break;
                            }
                            returnVector.push_back(mergeStates(previous));
                            break;
                        }
                        else if(!isCollision(shapeState) && y == shape.getY() - 1)
                        {
                            returnVector.push_back(mergeStates(shapeState));
                        }
                        previous = shapeState;
                    }
                }
            }
        }
        else{
            DebugLogger::error("Environment.cpp - shape larger than environment");
        }

    }
    return returnVector;
}

/*
* Function: testShape
* Parameters: 
*   int x_pass - x starting position within environment state
*   int y_pass - y starting position within environment state
*   int z_pass - z starting position within environment state
*   Shape shape - the shape to place in the given location
* Description: Generates an empty state, and places the given shape at
*   the specified coordinates. 
*/
State Environment::testShape(int x_pass, int z_pass, int y_pass, Shape shape)
{
    State shapeState;
    for(int x = x_pass; x < shape.getX() + x_pass; x++)
    {
        for(int z = z_pass; z < shape.getZ() + z_pass; z++)
        {
            for(int y = y_pass; y >= y_pass - (shape.getY() -1); y--)
            {
                shapeState.state[y][z][x] = true;
            }
        }
    }
    return shapeState;
}

/*
* Function: isCollision
* Parameters: 
*   Shape shapeState - the state containing only the shape (generated by testShape())
* Description: tests that the shapeState does not collide with the existing 
    shapes within the currentState. If it does, return true, otherwise, return false.
*/
bool Environment::isCollision(State shapeState)
{
    // Create local variables to make code more readable
    int envX = ControllerSettings::envShape.getX();
    int envY = ControllerSettings::envShape.getY();
    int envZ = ControllerSettings::envShape.getZ();
    for(int y = 0; y < envY; y++)
    {
        for(int z = 0; z < envZ; z++)
        {
            for(int x = 0; x < envX; x++)
            {
                if(currentState.state[y][z][x] 
                   && shapeState.state[y][z][x])
                   {
                       return true;
                   }
            }
        }
    }
    return false;
}

/*
* Function: mergeStates
* Parameters: 
*   Shape shapeState - the state containing only the shape (generated by testShape())
* Description: once the shape's position is placed as low as possible, that state 
    is passed in as shapeState to me merged on to the current state and returned
    as a new state to be checked if it is the optimal placement for the AI to select.
*/
State Environment::mergeStates(State shapeState)
{
    State tempState = currentState;
    // Create local variables to make code more readable
    int envX = ControllerSettings::envShape.getX();
    int envY = ControllerSettings::envShape.getY();
    int envZ = ControllerSettings::envShape.getZ();
    for(int y = 0; y < envY; y++)
    {
        for(int z = 0; z < envZ; z++)
        {
            for(int x = 0; x < envX; x++)
            {
                tempState.state[y][z][x] = currentState.state[y][z][x]
                                            || shapeState.state[y][z][x];
            }
        }
    }
    return tempState;
}

void Environment::updateState(State s)
{
    currentState = s;
}

State Environment::getCurrentState()
{
    return currentState;
}